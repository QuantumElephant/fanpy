from __future__ import absolute_import, division, print_function

from itertools import permutations, product
import numpy as np

from apig import Apig


class Apsetg(Apig):
    """
    Antisymmetrized Product of One Reference Orbital Geminals wavefunction.

    """

    _normalize = True

    def _make_npspace(self):
        """
        Number of Slater determinants in the projection space.

        """

        return self.npair * self.nbasis ** 2

    def _make_nhspace(self):
        """
        Number of excited Slater determinants generated by one application of the Hamiltonian to
        another Slater determinant.

        """

        nhspace = self.npair * (self.nbasis - self.npair + 1)
        return nhspace + nhspace * nhspace * 100

    def _make_dim_deriv(self):
        """
        Partitioning of parameters wrt which partial derivatives are taken.

        """

        return (self.nbasis, self.npair, self.nbasis)

    def _make_pspace(self):
        """
        Slater determinants for the projection space.

        """

        # Create a (#-SD)-by-(#-spatial-orbitals) boolean array
        pspace = np.zeros((self.npspace, 2 * self.nbasis), dtype=bool)

        # Add the ground (HF) state determinant to the cache
        pspace[0, :] = False
        pspace[0, :self.npair] = True
        pspace[0, self.nbasis:(self.nbasis + self.npair)] = True
        self.dict[tuple(pspace[0, :])] = 0
        i_index = 1

        # Generate determinants of increasing excitation order
        occ0 = permutations(range(0, self.nbasis), self.npair)
        occ1 = permutations(range(self.nbasis, 2 * self.nbasis), self.npair)
        for alpha, beta in product(occ0, occ1):
            pspace[i_index, :] = False
            pspace[i_index, alpha] = True
            pspace[i_index, beta] = True

            # If it's unique, add it to the cache, or else overwrite it
            key = tuple(pspace[i_index, :])
            if key not in self.dict:
                self.dict[key] = i_index
                i_index += 1
                if i_index == self.npspace:
                    return pspace

        # Every possible determinant has been generated
        return pspace

    def _make_hspace(self):
        """
        Excited Slater determinants from applying the Hamiltonian to the Slater determinants in
        self.pspace.

        """

        # Create a (#-SD)-by-(#-SD-per-Hamiltonian) boolean array
        hspace = np.zeros((self.npspace, self.nhspace, 2 * self.nbasis), dtype=bool)

        # Determine the current unique Slater determinant index
        i_index = len(self.dict)

        # Generate excited determinants by applying the Hamiltonian to the current determinants
        for sd in range(self.npspace):
            count = 0
            i_hspace = 0
            occ0 = [x for x, y in enumerate(self.pspace[sd, :]) if y]
            for i_count, i in enumerate(occ0):
                vir0 = [i]
                vir0.extend([x for x, y in enumerate(self.pspace[sd, :]) if not y])
                for k_count, k in enumerate(vir0):
                    occ1 = occ0[(i_count + 1):]
                    for j in occ1:
                        vir1 = [j]
                        vir1.extend(vir0[(k_count + 1):])
                        for l in vir1:
                            count += 1
                            good_sd = False
                            hspace[sd, i_hspace, :] = self.pspace[sd, :]
                            hspace[sd, i_hspace, (i, j, k, l)] = (False, False, True, True)
                            # If it's properly disjoint-set, check for uniqueness
                            nalpha = np.sum(hspace[sd, i_hspace, :self.nbasis])
                            nbeta = np.sum(hspace[sd, i_hspace, self.nbasis:])
                            if nalpha == nbeta == self.npair:
                                good_sd = True
                                key = tuple(hspace[sd, i_hspace, :])
                                # If unique, add it to the cache
                                if key not in self.dict:
                                    self.dict[key] = i_index
                                    i_index += 1
                                # Keep all determinants in hspace since they are used later
                                i_hspace += 1
            if not good_sd:
                hspace[sd, i_hspace - 1, :] = False

        # All necessary determinants have been generated
        return hspace

    def _make_index_occ(self):
        """
        Occupied indices for each unique Slater determinant.

        """

        index_occ = -np.ones((self.nsd, self.nelec), dtype=int)
        for key, value in self.dict.iteritems():
            index_occ[value, :] = [i for i in range(2 * self.nbasis) if key[i]]
        return index_occ

    def _make_index_vir(self):
        """
        Virtual indices for each unique Slater determinant.

        """

        index_vir = -np.ones((self.nsd, 2 * self.nbasis - self.nelec), dtype=int)
        for i in range(self.nsd):
            index_vir[i, :] = [j for j in range(2 * self.nbasis) if j not in self.index_occ[i, :]]
        return index_vir

    def _make_dir_olp(self):
        """
        Direct each Slater determinant in the projection space to its position in self.index_gen.

        """

        dir_olp = np.zeros(self.npspace, dtype=int)
        for i_pspace in range(self.npspace):
            key = tuple(self.pspace[i_pspace, :])
            try:
                value = self.dict[key]
            except KeyError:
                value = -1
            dir_olp[i_pspace] = value
        return dir_olp

    def _make_dir_ham(self):
        """
        Direct each excited Slater determinant from applying the Hamiltonian to its position in
        self.index_gen.

        """

        dir_ham = np.zeros((self.npspace, self.nhspace), dtype=int)
        for i_pspace in range(self.npspace):
            key = tuple(self.pspace[i_pspace, :])
            try:
                value = self.dict[key]
            except KeyError:
                value = -1
            for i_hspace in range(self.nhspace):
                try:
                    value = self.dict[tuple(self.hspace[i_pspace, i_hspace, :])]
                except KeyError:
                    value = -1
                dir_ham[i_pspace, i_hspace] = value
        return dir_ham

    def _make_x(self):
        """
        Generate an initial guess at the geminal coefficient vector.

        """

        # Generate empty matrix of proper shape and dtype
        dim = (self.nbasis, self.npair, self.nbasis)
        x = np.zeros(dim, dtype=self.dtype)

        # Add random noise
        x[...] += (0.2 / x.size) * (np.random.rand(*dim) - 0.5)

        # Return the raveled matrix as a vector
        x = x.ravel()
        return x

    def _make_C(self):
        """
        Generate a representation of the geminal coefficient matrix.

        """

        return self.x.reshape(self.nbasis, self.npair, self.nbasis)

    def _convert_to_apig(self, dtype=None):
        """
        Initialize an APIG coefficient matrix from this AP1roG instance.

        """

        raise NotImplementedError

    @staticmethod
    def _convert_from_apig(npair, nbasis, matrix):
        """
        Initialize an AP1roG coeficient vector from the APIG matrix.

        """

        raise NotImplementedError

    def _compute_overlap(self, index, deriv=None):
        """
        Compute the overlap of the indexth Slater determinant in the cache.

        """

        if deriv:
            cache_index = (index,) + deriv
            if self.dcache_status[cache_index]:
                return self.dcache_values[cache_index]
            else:
                cols = self.index_gen[index].tolist()
                if deriv[1] not in cols:
                    dolp = 0.
                else:
                    rows = list(range(self.ngem))
                    rows.remove(deriv[0])
                    cols.remove(deriv[1])
                    dolp = self.permanent(self.C[rows][:, cols])
                self.dcache_status[cache_index] = True
                self.dcache_values[cache_index] = dolp
                return dolp
        else:
            if self.ocache_status[index]:
                return self.ocache_values[index]
            else:
                olp = self.permanent(self.C[:, self.index_gen[index]])
                self.ocache_status[index] = True
                self.ocache_values[index] = olp
                return olp

def hamiltonian(self, sd, deriv=None):
        """
        Compute the Hamiltonian of the sdth Slater determinant in the projection space.

        """

        index = self.dir_olp[sd]
        gen = self.index_gen[index]
        occ = self.index_occ[index]
        vir = self.index_vir[index]

        # Call the cache instance to compute the overlap
        olp = self._compute_overlap(index, deriv)

        # Get spin indices
        ind_occ = [i for i in range(2 * self.norbs) if is_occupied(phi, i)]
        ind_virt = [i for i in range(2 * self.norbs) if not is_occupied(phi, i)]
        one_electron = 0.0
        coulomb = 0.0
        exchange = 0.0
        ind_first_occ = 0

        for i in ind_occ:
            ind_first_virt = 0
            # Add `i` to `ind_virt` because excitation to same orbital is possible
            tmp_ind_virt_1 = sorted(ind_virt + [i])

            for k in tmp_ind_virt_1:
                single_excitation = excite_orbs(phi, i, k)
                if i % 2 == k % 2:
                    one_electron += one[i // 2, k // 2] * self.overlap(single_excitation, coeffs)
                # Avoid repetition by ensuring  `j > i` is satisfied
                for j in ind_occ[ind_first_occ + 1:]:
                    # Add indices `i` and `j` to `ind_virt` because excitation to same
                    # orbital is possible, and avoid repetition by ensuring `l > k` is
                    # satisfied
                    tmp_ind_virt_2 = sorted([j] + tmp_ind_virt_1[ind_first_virt + 1:])
                    for l in tmp_ind_virt_2:
                        double_excitation = excite_orbs(single_excitation, j, l)
                        overlap = self.overlap(double_excitation, coeffs)
                        if overlap == 0:
                            continue
                        # In <ij|kl>, `i` and `k` must have the same spin, as must
                        # `j` and `l`
                        if i % 2 == k % 2 and j % 2 == l % 2:
                            coulomb += two[i // 2, j // 2, k // 2, l // 2] * overlap
                        # In <ij|lk>, `i` and `l` must have the same spin, as must
                        # `j` and `k`
                        if i % 2 == l % 2 and j % 2 == k % 2:
                            exchange -= two[i // 2, j // 2, l // 2, k // 2] * overlap

                ind_first_virt += 1
            ind_first_occ += 1

        return one_electron, coulomb, exchange


# vim: set nowrap textwidth=100 cc=101 :
