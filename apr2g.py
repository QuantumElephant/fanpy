from __future__ import absolute_import, division, print_function

import numpy as np

from apig import Apig


class Apr2g(Apig):
    """
    Antisymmetrized Product of Rank Two Geminals wavefunction.

    """

    _normalize = True

    _solver_options = Apig._solver_options.copy()
    _solver_options.update({})

    def _make_npspace(self):
        """
        Number of Slater determinants in the projection space.

        """

        return self.npair + 2 * self.nbasis

    def _make_nhspace(self):
        """
        Number of excited Slater determinants generated by one application of the Hamiltonian to
        another Slater determinant.

        """

        return self.npair * (self.nbasis - self.npair)

    def _make_dim_deriv(self):
        """
        Partitioning of parameters wrt which partial derivatives are taken.

        """

        return (self.npair + 2 * self.nbasis,)

    def _make_C(self):
        """
        Generate a representation of the geminal coefficient matrix.

        """

        return np.empty((self.npair, self.nbasis), dtype=self.dtype)

    def _convert_to_apig(self, dtype=None):
        """
        Initialize an APIG coefficient matrix from this AP1roG instance.

        """

        dtype = self.dtype if dtype is None else dtype
        self.update_x(self.x)
        matrix = self.C.copy()
        return matrix

    @staticmethod
    def _convert_from_apig(npair, nbasis, matrix):
        """
        Initialize an APr2G coefficient vector from the APIG matrix.

        """

        # Construct a least-squares augmented matrix
        A = np.zeros((matrix.size, npair + 2 * nbasis), dtype=matrix.dtype)
        lambdas = A[:,:npair]
        epsilons = A[:,npair:(npair + nbasis)]
        zetas = A[:,(npair + nbasis):]
        for i in range(npair):
            j = i * nbasis
            lambdas[j:(j + nbasis), i] = matrix[i, :]
            epsilons[j:(j + nbasis), :] = np.diag(-matrix[i, :])
            zetas[j:(j + nbasis), :] = -np.eye(nbasis)

        # Solve the least-squares system
        sol = np.linalg.lstsq(A[:, :-1], -A[:, -1])[0]
        x = np.zeros(sol.size + 1, dtype=sol.dtype)
        x[:-1] = sol
        x[-1] = 1
        return x

    def update_x(self, x):
        """
        Generate the guess at the geminal coefficient vector.

        """

        self.x[:] = x
        sep = self.npair + self.nbasis
        for i in range(self.npair):
            for j in range(self.nbasis):
                self.C[i, j] = self.x[sep + j] / (self.x[i] - self.x[self.npair + j])


# vim: set nowrap textwidth=100 cc=101 :
