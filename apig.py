from __future__ import absolute_import, division, print_function

from itertools import permutations, product

import numpy as np
from scipy.optimize import least_squares

import f90perm


class Apig(object):
    """
    Antisymmetrized Product of Interacting Geminals wavefunction.

    """

    _normalize = True

    _solver_options = {
        "bounds":  (-1, +1),
        "jac":     True,
        "verbose": 2,
        "ftol":    1.0e-09,
        "gtol":    1.0e-09,
        "xtol":    1.0e-12,
    }

    permanent = staticmethod(f90perm.ryser)

    def __init__(self, nelec, H, G, dtype=np.float64, extra=0, x=None):
        """
        Initialize the APIG wavefunction instance.

        """

        # Set argument-specified attributes
        self.nelec = nelec
        self.H     = H
        self.G     = G
        self.dtype = dtype

        # Set number of electron pairs and number of spatial basis functions
        self.npair  = nelec // 2
        self.nbasis = H.shape[0]

        # Set Slater determinant counts
        self.npspace = self._make_npspace() + extra
        self.nhspace = self._make_nhspace()

        # Set objective function and Jacobian dimensions
        self.dim_deriv = self._make_dim_deriv()
        self.dim_obj   = self._make_dim_obj()
        self.dim_jac   = self._make_dim_jac()

        # Initialize Slater determinant indexing
        self.dict   = {}
        self.pspace = self._make_pspace()
        self.hspace = self._make_hspace()

        # Set total number of Slater determinants cached
        self.nsd = len(self.dict)

        # Populate Slater determinant occupied/virtual indices
        self.index_gen = self._make_index_gen()
        self.index_occ = self._make_index_occ()
        self.index_vir = self._make_index_vir()

        # Direct each Slater determinant used in further computations to its index
        self.dir_olp = self._make_dir_olp()
        self.dir_ham = self._make_dir_ham()

        # Initialize Slater determinant overlap caching
        self.ocache_status = np.zeros(self.nsd, dtype=bool)
        self.ocache_values = np.zeros(self.nsd, dtype=self.dtype)
        self.dcache_status = np.zeros((self.nsd,) + self.dim_deriv, dtype=bool)
        self.dcache_values = np.zeros((self.nsd,) + self.dim_deriv, dtype=self.dtype)

        # Initialize geminal coefficient vector/matrix
        self.x = self._make_x() if x is None else x
        self.C = self._make_C()

    def __call__(self, **kwargs):

        # Update solver options
        options = self._solver_options.copy()
        options.update(kwargs)

        # Decide which Jacobian approximation (if any) to use
        if options["jac"] is True:
            options["jac"] = self.jacobian
        elif not options["jac"]:
            options["jac"] = "cs" if self.dtype == np.complex128 else "3-point"

        # Solve
        result = least_squares(self.objective, self.x, **options)
        return result

    def _make_npspace(self):
        """
        Number of Slater determinants in the projection space.

        """

        return self.npair * self.nbasis

    def _make_nhspace(self):
        """
        Number of excited Slater determinants generated by one application of the Hamiltonian to
        another Slater determinant.

        """

        return self.npair * (self.nbasis - self.npair)

    def _make_dim_deriv(self):
        """
        Partitioning of parameters wrt which partial derivatives are taken.

        """

        return (self.npair, self.nbasis)

    def _make_dim_obj(self):
        """
        Dimension of the objective function vector.

        """

        return (self.npspace,)

    def _make_dim_jac(self):
        """
        Dimension of the objective function's Jacobian.

        """

        return self.dim_obj + (np.prod(self.dim_deriv),)

    def _make_pspace(self):
        """
        Slater determinants for the projection space.

        """

        # Create a (#-SD)-by-(#-spatial-orbitals) boolean array
        pspace = np.zeros((self.npspace, self.nbasis), dtype=bool)

        # Add the ground (HF) state determinant to the cache
        pspace[0, :self.npair] = True
        pspace[0, self.npair:] = False
        self.dict[tuple(pspace[0, :])] = 0
        i_index = 1

        # Generate determinants of increasing excitation order
        for nexc in range(1, self.npair + 1):

            # Generate every possible determinant for the current excitation order
            for occ in permutations(range(self.npair - 1, -1, -1), nexc):
                for vir in permutations(range(self.npair, self.nbasis), nexc):

                    # Generate each determinant in place
                    pspace[i_index, :] = pspace[0, :]
                    for o in occ:
                        pspace[i_index, o] = False
                    for v in vir:
                        pspace[i_index, v] = True

                    # If it's unique, add it to the cache, or else overwrite it next time
                    key = tuple(pspace[i_index, :])
                    if key not in self.dict:
                        self.dict[key] = i_index
                        i_index += 1
                        if i_index == self.npspace:
                            return pspace

        # Every possible determinant has been generated
        return pspace

    def _make_hspace(self):
        """
        Excited Slater determinants from applying the Hamiltonian to the Slater determinants in
        self.pspace.

        """

        # Create a (#-SD)-by-(#-SD-per-Hamiltonian) boolean array
        hspace = np.zeros((self.npspace, self.nhspace, self.nbasis), dtype=bool)

        # Determine the current unique Slater determinant index
        i_index = len(self.dict)

        # Generate excited determinants by applying the Hamiltonian to the current determinants
        for sd in range(self.npspace):
            i_hspace = 0
            for o in range(self.nbasis):
                if self.pspace[sd, o]:
                    for v in range(self.nbasis):
                        if not self.pspace[sd, v]:
                            hspace[sd, i_hspace, :] = self.pspace[sd, :]
                            hspace[sd, i_hspace, o] = False
                            hspace[sd, i_hspace, v] = True
                            key = tuple(hspace[sd, i_hspace, :])

                            # If it's unique, add it to the cache
                            if key not in self.dict:
                                self.dict[key] = i_index
                                i_index += 1

                            # Keep all determinants in hspace since they are used later
                            i_hspace += 1

        # All necessary determinants have been generated
        return hspace

    def _make_index_gen(self):
        """
        General indices for each unique Slater determinant.

        """

        return self._make_index_occ()

    def _make_index_occ(self):
        """
        Occupied indices for each unique Slater determinant.

        """

        index_occ = -np.ones((self.nsd, self.npair), dtype=int)
        for key, value in self.dict.iteritems():
            occ = [i for i in range(self.nbasis) if key[i]]
            index_occ[value, :] = occ
        return index_occ

    def _make_index_vir(self):
        """
        Virtual indices for each unique Slater determinant.

        """

        index_vir = -np.ones((self.nsd, self.nbasis - self.npair), dtype=int)
        for i in range(self.nsd):
            index_vir[i, :] = [j for j in range(self.nbasis) if j not in self.index_occ[i, :]]
        return index_vir

    def _make_dir_olp(self):
        """
        Direct each Slater determinant in the projection space to its position in self.index_gen.

        """

        dir_olp = np.zeros(self.npspace, dtype=int)
        for i_pspace in range(self.npspace):
            key = tuple(self.pspace[i_pspace, :])
            value = self.dict[key]
            dir_olp[i_pspace] = value
        return dir_olp

    def _make_dir_ham(self):
        """
        Direct each excited Slater determinant from applying the Hamiltonian to its position in
        self.index_gen.

        """

        dir_ham = np.zeros((self.npspace, self.nhspace), dtype=int)
        for i_pspace in range(self.npspace):
            key = tuple(self.pspace[i_pspace, :])
            value = self.dict[key]
            for i_hspace in range(self.nhspace):
                value = self.dict[tuple(self.hspace[i_pspace, i_hspace, :])]
                dir_ham[i_pspace, i_hspace] = value
        return dir_ham

    def _make_x(self):
        """
        Generate an initial guess at the geminal coefficient vector.

        """

        # Generate identity matrix of proper shape and dtype
        x = np.zeros((self.npair, self.nbasis), dtype=self.dtype)
        x[:, :] += np.eye(self.npair, self.nbasis)

        # Add random noise (real, and complex if necessary)
        x[:, :] += (0.2 / x.size) * (np.random.rand(self.npair, self.nbasis) - 0.5)
        if self.dtype == np.complex128:
            x[:, :] += (0.02j / x.size) * (np.random.rand(self.npair, self.nbasis) - 0.5)

        # Normalize and return the raveled matrix as a vector
        x[:, :] /= np.max(np.abs(x))
        x = x.ravel()
        return x

    def _make_C(self):
        """
        Generate a representation of the geminal coefficient matrix.

        """

        return self.x.reshape(self.npair, self.nbasis)

    def _compute_overlap(self, index, deriv=None):
        """
        Compute the overlap of the indexth Slater determinant in the cache.

        """

        if deriv:
            cache_index = (index,) + deriv
            if self.dcache_status[cache_index]:
                return self.dcache_values[cache_index]
            else:
                cols = self.index_gen[index].tolist()
                if deriv[1] not in cols:
                    dolp = 0.
                else:
                    rows = list(range(self.npair))
                    rows.remove(deriv[0])
                    cols.remove(deriv[1])
                    dolp = self.permanent(self.C[rows][:, cols])
                self.dcache_status[cache_index] = True
                self.dcache_values[cache_index] = dolp
                return dolp
        else:
            if self.ocache_status[index]:
                return self.ocache_values[index]
            else:
                olp = self.permanent(self.C[:, self.index_gen[index]])
                self.ocache_status[index] = True
                self.ocache_values[index] = olp
                return olp

    def clear(self):
        """
        Clear the objective and Jacobian caches.

        """

        self.ocache_status[...] = False
        self.dcache_status[...] = False

    def update_x(self, x):
        """
        Generate the guess at the geminal coefficient vector.

        """

        self.x[:] = x

    def overlap(self, sd, deriv=None):
        """
        Compute the overlap of the sdth Slater determinant in the projection space.

        """

        return self._compute_overlap(self.dir_olp[sd], deriv)

    def energy(self, sd=0, deriv=None):
        """
        Compute the energy of the APIG wavefunction.

        """

        return sum(self.hamiltonian(sd, deriv))

    def hamiltonian(self, sd, deriv=None):
        """
        Compute the Hamiltonian of the sdth Slater determinant in the projection space.

        """

        # Query the determinant's cache index and its occupied/virtual indices
        index = self.dir_olp[sd]
        gen = self.index_gen[index]
        occ = self.index_occ[index]
        vir = self.index_vir[index]

        # Call the cache instance to compute the overlap
        olp = self._compute_overlap(index, deriv)

        # Compute one-electron energy
        one_electron = 0.
        for i in occ:
            one_electron += 2 * self.H[i, i]
        one_electron *= olp

        # Compute direct two-electron energy
        i_exc = 0
        direct = 0.
        direct_tmp = 0.0
        for jstart, i in enumerate(occ):
            direct += self.G[i, i, i, i]
            for j in occ[jstart + 1:]:
                direct += 4 * self.G[i, j, i, j]
            for j in vir:
                index = self.dir_ham[sd, i_exc]
                direct_tmp += self.G[i, i, j, j] * self._compute_overlap(index, deriv)
                i_exc += 1
        direct *= olp
        direct += direct_tmp

        # Compute exchange two-electron energy
        exchange = 0.
        for jstart, i in enumerate(occ):
            for j in occ[jstart + 1:]:
                exchange -= 2 * self.G[i, j, j, i]
        exchange *= olp

        # Done
        return one_electron, direct, exchange

    def objective(self, x):
        """
        Compute the objective function for optimizing the geminal coefficent matrix.

        """

        # Update the coefficient vector/matrix
        self.update_x(x)

        # Clear the cache
        self.clear()

        # Intialize needed variables
        obj = np.zeros(self.dim_obj, dtype=x.dtype)
        g_olp = self.overlap(0)
        g_energy = self.energy(0)

        if self._normalize:
            # Impose <HF|Psi> == 1
            obj[0] = g_olp - 1.0

        # Impose <SD|H|Psi> - E * <SD|H|Psi> == 0
        for sd in range(int(self._normalize), self.npspace):
            obj[sd] = self.energy(sd) - g_energy * self.overlap(sd)

        return obj

    def jacobian(self, x):
        """
        Compute the Jacobian of the objective function for optimizing the geminal coefficient
        matrix.

        """

        # Update the coefficient vector/matrix
        self.update_x(x)

        # Clear the cache
        self.clear()

        # Intialize persistent variables
        g_energy = self.energy(0)
        jac = np.zeros(self.dim_jac, dtype=x.dtype)

        # Loop through all coefficients
        for c, deriv in enumerate(product(*map(range, self.dim_deriv))):

            # Update variables
            d_g_olp = self.overlap(0, deriv)
            d_g_energy = self.energy(0, deriv)

            if self._normalize:
                # Impose d<HF|Psi> == 0
                jac[0, c] = d_g_olp

            # Impose d(<SD|H|Psi> - E * <SD|H|Psi>) == 0
            for sd in range(int(self._normalize), self.npspace):
                jac[sd, c] = self.energy(sd, deriv) - \
                    g_energy * self.overlap(sd, deriv) - d_g_energy * self.overlap(sd)

        # Jacobian is 2x too large (why?)
        return 0.5 * jac

    def to_apr2g(self, instance=False, dtype=None):
        """
        Initialize an APr2G wavefunction instance using this APIG instance's coefficient vector as
        the initial guess for the APr2G coefficient vector.

        """

        # Construct a least-squares augmented matrix
        dtype = self.dtype if dtype is None else dtype
        A = np.zeros((self.C.size, self.npair + 2 * self.nbasis), dtype=dtype)
        lambdas = A[:,:self.npair]
        epsilons = A[:,self.npair:(self.npair + self.nbasis)]
        zetas = A[:,(self.npair + self.nbasis):]
        for i in range(self.npair):
            j = i * self.nbasis
            lambdas[j:(j + self.nbasis), i] = self.C[i, :]
            epsilons[j:(j + self.nbasis), :] = np.diag(-self.C[i, :])
            zetas[j:(j + self.nbasis), :] = -np.eye(self.nbasis)

        # Solve the least-squares system
        sol = np.linalg.lstsq(A[:, :-1], -A[:, -1])[0]
        x = np.zeros(sol.size + 1, dtype=sol.dtype)
        x[:-1] = sol
        x[-1] = 1

        # Return the coefficient vector or a new Apr2g instance
        if instance:
            extra = self.npspace - self._make_npspace()
            pass #return Apr2g(self.nelec, self.H, self.G, dtype=dtype, extra=extra, x=x)
        else:
            #return x
            cauchy = np.zeros_like(self.C)
            for i in range(self.npair):
                for j in range(self.nbasis):
                    cauchy[i, j] = x[self.npair + self.nbasis + j] / (x[i] - x[self.npair + j])
            err = (cauchy - self.C) / self.C
            return x, cauchy, err


# vim: set nowrap textwidth=100 cc=101 :
